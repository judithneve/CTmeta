% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CTmeta.R
\name{CTmeta}
\alias{CTmeta}
\title{Continuous-time meta-analysis on standarized lagged effects}
\usage{
CTmeta(
  N,
  DeltaT,
  DeltaTStar,
  Phi,
  SigmaVAR = NULL,
  Gamma = NULL,
  Moderators = 0,
  Mod = NULL,
  FEorRE = 1,
  alpha = 0.05,
  PrintPlot = FALSE
)
}
\arguments{
\item{N}{Number of persons (panel data) or number of measurement occasions - 1 (time series data) used in the S primary studies. Matrix of size S times 1.}

\item{DeltaT}{The time intervals used in the S primary studies. Matrix of size S times 1. Note that all the time intervals should be on the same scale (e.g., two time-intervals of 60 minutes and 2 hours, should be either 60 and 120 or 1 and 2).}

\item{DeltaTStar}{The time interval (scalar) to which the standardized lagged effects matrix should be transformed to.}

\item{Phi}{Stacked matrix of size S*q times q or array with dimensions q times q times S of (un)standardized lagged effects matrices for all S primary studies in the meta-analysis; with q the number of variables (leading to an q times q lagged effects matrix in a single primary study). Note: In case primary studies report (lagged) correlation matrices, one can use the function 'TransPhi_Corr' to transform those to the corresponding standardized lagged effects matrices (see ?TransPhi_Corr and examples below).}

\item{SigmaVAR}{Stacked matrix of size S*q times q or array with dimensions q times q times S of residual covariance matrices of the first-order discrete-time vector autoregressive (DT-VAR(1)) model.}

\item{Gamma}{Optional (either SigmaVAR or Gamma). Stacked matrix of size S*q times q or array with dimensions q times q times S of stationary covariance matrices, that is, the contemporaneous covariance matrices of the data sets.
Note that if Phi and Gamma are known, SigmaVAR can be calculated. Hence, only SigmaVAR or Gamma is needed as input (if only Gamma, then use 'Gamma = Gamma' or set SigmaVAR to NULL, see examples below).}

\item{Moderators}{Optional. Indicator (TRUE/FALSE or 1/0) whether there are moderators to be included (TRUE or 1) or not (FALSE or 0). By default, Moderators = 0.}

\item{Mod}{Optional. An S x m matrix of m moderators to be included in the analysis when Moderators == 1. By default, Mod = NULL.}

\item{FEorRE}{Optional. Indicator (2/1) whether continuous-time meta-analysis should use a fixed-effects model (1) or random-effects model (2). By default, FEorRE = 1.}

\item{alpha}{Optional. The alpha level in determining the (1-alpha)*100\% confidence interval (CI). By default, alpha = 0.05; resulting in a 95\% CI.}

\item{PrintPlot}{Optional. Indicator (TRUE/FALSE or 1/0) for rendering a Phi-plot (TRUE or 1) or not (FALSE or 0). By default, PrintPlot = FALSE.}
}
\value{
The output comprises, among others, the overall vectorized transformed standardized lagged effects, their covariance matrix, and the corresponding elliptical/multivariate 95\% CI.
}
\description{
Continuous-time meta-analysis (CTmeta) on standarized lagged effects (Phi) taking into account the various time-intervals used in the primary studies. There is also an interactive web application on my website to perform CTmeta: \url{https://www.uu.nl/staff/RMKuiper/Websites\%20\%2F\%20Shiny\%20apps}.
}
\examples{

# library(CTmeta)

##################################################################################################
# Input needed in examples below with q=2 variables and S=3 primary studies
#
N <- matrix(c(643, 651, 473))
DeltaT <- matrix(c(2, 3, 1))
DeltaTStar <- 1
#
# I will use the example matrices stored in the package:
Phi <- myPhi
SigmaVAR <- mySigmaVAR
Gamma <- myGamma # Note: CTmeta does not need both SigmaVAR and Gamma, as denomstrated below.
# These are all three stacked matrices of size S*q times q.
# The CTmeta function will standardize these matrices (to make comparison of effects meaningful).
#
Moderators = 0 # By default set to 0. Hence, not per se needed, as denomstrated below.
##################################################################################################


## Example without moderators ##

# Fixed effects model #

# Run CTmeta with, for instance,
CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma)

# There are multiple options; use one of the following:
CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR, Gamma, Moderators, Mod, 1)
CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR, Gamma, Moderators, Mod)
CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR, Gamma, Moderators)
CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR, Gamma)
CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR)
CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR = SigmaVAR)
CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma)
CTmeta(N, DeltaT, DeltaTStar, Phi, NULL, Gamma)

# Note: Do NOT use
#CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma)
# Then, CTmeta incorrectly uses SigmaVAR = Gamma.

# Different types of output options are possible:
CTm <- CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma)
CTm
print(CTm)
summary(CTm)
print(CTm, digits = 4)
summary(CTm, digits = 4)
# In Rstudio, use 'CTm$' to see what output there is. For example:
CTm$summaryMetaAnalysis


# Random effects model #

# Add "FEorRE = 2"; e.g.,
CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma, FEorRE = 2)


## Example with moderators ##

Mod <- matrix(c(64,65,47)) # 1 moderator
#q <- dim(Phi)[2]; Mod <- matrix(cbind(c(64,65,47), c(78,89,34)), ncol = q); colnames(Mod) <- c("Mod1", "Mod2") # two moderators, in each column 1
CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma, Moderators = 1, Mod = Mod) # fixed effects model
#CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma, Moderators = 1, Mod = Mod, FEorRE = 2) # random effects model



## Make customized Phi-plot of resulting overall Phi ##

# Option 1: Using the plot option in the function:
CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma, PrintPlot = TRUE)


# Option 2: A customized Phi-plot can be made using the function 'PhiPlot' (see below) or by using the interactive web app from my website (\url{https://www.uu.nl/staff/RMKuiper/Websites\\%20\\%2F\\%20Shiny\\%20apps}).
# Alternatively, one can use the function 'ggPhiPlot' instead of 'PhiPlot'.

# Extract the (q times q) overall Phi matrix
out_CTmeta <- CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma)
# resulting overall Phi:
overallPhi <- out_CTmeta$Overall_standPhi

# Make Phi-plot:
Title <- as.list(expression(paste0(Phi(Delta[t]), " plot:"),
   "How do the overall lagged parameters vary as a function of the time-interval"))
PhiPlot(DeltaTStar, overallPhi, Min = 0, Max = 40, Step = 0.5, Title = Title)
# or
ggPhiPlot(DeltaTStar, overallPhi, Min = 0, Max = 40, Step = 0.5, Title = Title)



## Evaluate dominance of cross-lagged effects ##

# Extract the vectorized overall standardized overallPhi matrix and its covariance matrix
out_CTmeta <- CTmeta(N, DeltaT, DeltaTStar, Phi, Gamma = Gamma)
est <- out_CTmeta$Overall_vecStandPhi_DeltaTStar
VCOV <- out_CTmeta$CovMx_OverallPhi_DeltaTStar
# Specify hypothesis
H1 <- "overallPhi12 < overallPhi21"
#H2 <- "overallPhi12 > overallPhi21"
# Evaluate dominance of cross-lagged effects via AIC-type criterion called the GORICA (Altinisik, Nederhof, Hoijtink, Oldehinkel, Kuiper, conditionally accepted).
if (!require("restriktor")) install.packages("restriktor")
# Use restriktor package for function goric().
# Authors of goric(): Vanbrabant and Kuiper.
library(restriktor)
#goric(est, VCOV = VCOV, H1, H2, type = "gorica", comparison = "none")
# or equivalently:
goric(est, VCOV = VCOV, H1, type = "gorica", comparison = "complement")



## What if primary studies report a (lagged) correlation matrix ##

# Supose all S=3 primary studies reported the following lagged correlation matrix:
q <- 2
corr_YXYX <- matrix(c(1.00, 0.40, 0.63, 0.34,
                      0.40, 1.00, 0.31, 0.63,
                      0.63, 0.31, 1.00, 0.41,
                      0.34, 0.63, 0.41, 1.00), byrow = T, ncol = 2*q)

# In the example below, the same N and DeltaT(Star) values are used:
N <- matrix(c(643, 651, 473))
DeltaT <- matrix(c(2, 3, 1))
DeltaTStar <- 1

# Use the function 'TransPhi_Corr' to calculate the corresponding standardized lagged effects matrix per primary study.
# Note that one can already make the time-intervals equal via the arguments DeltaTStar and DeltaT, but CTmeta can as well.
# In this example, I deliberately make the time-intervals unequal, such that the example is in line with the input (i.e., DeltaT <- matrix(c(2, 3, 1))) and such the resulting overall Phi should equal the Phi that underlies this lagged correlation matrix (which I check at the end).
out_1 <- TransPhi_Corr(DeltaTStar = DeltaT[1], DeltaT = 1, N = N[1], corr_YXYX)
Phi_1 <- out_1$standPhi_DeltaTStar
SigmaVAR_1 <- out_1$standSigmaVAR_DeltaTStar
out_2 <- TransPhi_Corr(DeltaTStar = DeltaT[2], DeltaT = 1, N = N[2], corr_YXYX)
Phi_2 <- out_2$standPhi_DeltaTStar
SigmaVAR_2 <- out_2$standSigmaVAR_DeltaTStar
out_3 <- TransPhi_Corr(DeltaTStar = DeltaT[3], DeltaT = 1, N = N[3], corr_YXYX)
Phi_3 <- out_3$standPhi_DeltaTStar
SigmaVAR_3 <- out_3$standSigmaVAR_DeltaTStar

# Make Phi
Phi <- rbind(Phi_1, Phi_2, Phi_3) # This, returns a stacked matrix of size S q times q.
SigmaVAR <- rbind(SigmaVAR_1, SigmaVAR_2, SigmaVAR_3)
# For more details, see ?TransPhi_Corr

# The example CTmeta() code above can be run using this Phi; e.g.,
CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR)

# The overall q-times-q (here, 2x2) lagged effects matrix Phi
out_CTmeta <- CTmeta(N, DeltaT, DeltaTStar, Phi, SigmaVAR)
out_CTmeta$Overall_standPhi
#
# As a check, to see indeed that CTmeta works properly (where the resulting Phi is independent of the choise of N).
TransPhi_Corr(DeltaTStar = 1, DeltaT = 1, N = 100, corr_YXYX)$standPhi_DeltaTStar
# Note that is normally not a check you would do.

}
