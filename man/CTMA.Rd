% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CTmeta.R
\name{CTMA}
\alias{CTMA}
\title{Transforms the lagged effect estimates for a given interval to the ones corresponding to a different time-interval}
\usage{
CTMA(N, TypeMx, Phi, SigmaVAR, Gamma, DeltaTStar, DeltaT, Moderators = 0,
  Mod = NULL, FEorRE = 1, alpha = 0.05)
}
\arguments{
\item{N}{Number of persons (panel data) or measurement occasions - 1 (time series data) used in the S studies. Matrix of size S times 1.}

\item{TypeMx}{Indicator of type of matrix for Phi, SigmaVAR, and Gamma: 0) Stacked matrix of size S q times q; 2) Array with dimensions q times q times S; with S the number of studies in the meta-analysis and q the number of variables (leading to an q times q lagged effects matrix Phi).}

\item{Phi}{Stacked matrix (TypeMx == 0) or array (TypeMx == 1) of (un)standardized lagged effects matrices for all S studies in the meta-analysis.}

\item{SigmaVAR}{Stacked matrix (TypeMx == 0) or array (TypeMx == 1) of residual covariance matrices of the first-order discrete-time vector autoregressive (DT-VAR(1)) model.}

\item{Gamma}{Stacked matrix (TypeMx == 0) or array (TypeMx == 1) of stationary covariance matrices, that is, the contemporaneous covariance matrices of the data sets.}

\item{DeltaTStar}{The time interval (scalar) to which the standardized lagged effects matrix should be transformed to.}

\item{DeltaT}{The time intervals used in the S studies. Matrix of size S times 1.}

\item{Moderators}{Indicator whether there are moderators to be included (1) or not (0; default).}

\item{Mod}{Matrix of moderators to be included in the analysis when Moderators == 1. By default, Mod = NULL.}

\item{FEorRE}{Indicator whether continuous-time meta-analysis (CTmeta) should use a fixed-effects model (1; default) or random-effects model (2).}

\item{alpha}{The alpha level in determining the (1-alpha)*100 percent confidence interval (CI). By default, alpha is set to 0.05, resulting in a 95 percent CI.}
}
\value{
vectorized transformed standardized lagged effects, their covariance matrix, and the corresponding elleptical/multivariate 95 percent CI.
}
\description{
Transforms the lagged effect estimates for a given interval to the ones corresponding to a different time-interval
}
\examples{

###########################################################
### Input for examples ###
q = 2 # Number of variables in the process/system
S = 3 # Number of studies included in the meta-analysis

## Phi as S q times q matrix (TypeMx == 0) ##

# Based on discrete-time model #
Phi <- matrix(c(0.25, 0.10,
                0.20, 0.36,
                0.35, 0.20,
                0.30, 0.46,
                0.15, 0.00,
                0.10, 0.26), byrow = T, ncol = q)

# Based on correlation matrix #
corr_YXYX <- matrix(c(1.00, 0.40, 0.63, 0.34,
                      0.40, 1.00, 0.31, 0.63,
                      0.63, 0.31, 1.00, 0.41,
                      0.34, 0.63, 0.41, 1.00), byrow = T, ncol = 2*q)
out <- calc.TransPhi_Corr(12, 24, 2235, corr_YXYX)
Phi_1 <- matrix(out$vecStandPhi_DeltaTStar, byrow = T, ncol = q)
Phi_2 <- matrix(out$vecStandPhi_DeltaTStar, byrow = T, ncol = q)
Phi_3 <- matrix(out$vecStandPhi_DeltaTStar, byrow = T, ncol = q)
Phi <- rbind(Phi_1, Phi_2, Phi_3)


## SigmaVAR and Gamma as S q times q matrix (TypeMx == 0) ##
# Based on discrete-time model, using SigmaVAR #
SigmaVAR_s <- diag(q) # for ease
SigmaVAR <- rbind(SigmaVAR_s, SigmaVAR_s, SigmaVAR_s)
# If Phi and SigmaVAR are known, one can calculate Gamma:
Gamma <- array(data=NA, dim=c(S*q,q))
teller <- 1
for(s in 1:S){
  Gamma[teller:(teller+1),] <- calc.Gamma.fromVAR(Phi[teller:(teller+1),], SigmaVAR[teller:(teller+1),])
  teller <- teller + q
}

# Based on discrete-time model, using Gamma #
# Use Gamma from above
# If Phi and SigmaVAR are known, one can calculate Gamma:
SigmaVAR <- array(data=NA, dim=c(S*q,q))
teller <- 1
for(s in 1:S){
  SigmaVAR[teller:(teller+1),] <- Gamma[teller:(teller+1),] - Phi[teller:(teller+1),] \%*\% Gamma[teller:(teller+1),] \%*\% t(Phi[teller:(teller+1),])
  teller <- teller + q
}

# Based on correlation matrix #
# Use 'out' from above. # out <- calc.TransPhi_Corr(12, 24, 2235, corr_YXYX)
SigmaVAR_1 <- out$SigmaVAR_DeltaTStar
Gamma_1 <- out$Gamma
# Do this for each study to make a stacked matrix out of this

## Phi as array with dimensions q times q times S (TypeMx == 1) ##

# Based on discrete-time model #
# Use Phi from above
Phi_studies <- array(data=NA, dim=c(q,q,S))
teller = 0
for(s in 1:S){
  Phi_studies[1:q,1:q,s] <- matrix(t(Phi)[(teller+1):(teller+q*q)], byrow = T, ncol=q*q)
  Phi_studies[1:q,1:q,s] <- t(Phi_studies[1:q,1:q,s])
  teller = teller + q*q
}
#Phi <- Phi_studies

# Use SigmaVAR from above
SigmaVAR_studies <- array(data=NA, dim=c(q,q,S))
teller = 0
for(s in 1:S){
  SigmaVAR_studies[1:q,1:q,s] <- SigmaVAR[(teller+1):(teller+q),1:q]
  teller = teller + q
}
#SigmaVAR <- SigmaVAR_studies
Gamma_studies <- array(data=NA, dim=c(q,q,S))
for(s in 1:S){
  Gamma_studies[,,s] <- calc.Gamma.fromVAR(Phi_studies[,,s], SigmaVAR_studies[,,s])
}
#Gamma <- CovMx_studies

# Use Gamma from above
Gamma_studies <- array(data=NA, dim=c(q,q,S))
teller = 0
for(s in 1:S){
  Gamma_studies[1:q,1:q,s] <- Gamma[(teller+1):(teller+q),1:q]
  teller = teller + q
}
#Gamma <- CovMx_studies
SigmaVAR_studies <- array(data=NA, dim=c(q,q,S))
for(s in 1:S){
  SigmaVAR_studies[,,s] <- Gamma_studies[,,s] - Phi_studies[,,s] \%*\% Gamma_studies[,,s] \%*\% t(Phi_studies[,,s])
}
#SigmaVAR <- SigmaVAR_studies


# The study-specific sampel size (N) and time interval (DeltaT)
DeltaT <- matrix(c(2, 3, 1))
N <- matrix(c(643, 651, 473))
###########################################################


# Based on input above, one can run one of these two CTmeta analyses
DeltaTStar <- 1
CTMA(N, 1, Phi_studies, SigmaVAR_studies, Gamma_studies, DeltaTStar, DeltaT)
CTMA(N, 0, Phi, SigmaVAR, Gamma, DeltaTStar, DeltaT)


# In case of moderators
Mod <- matrix(c(64,65,47)) # 1 moderator
#Mod <- matrix(cbind(c(64,65,47), c(78,89,34)), ncol = q); colnames(Mod) <- c("Mod1", "Mod2") # two moderators, in each column 1
CTMA(N, 1, Phi_studies, SigmaVAR_studies, Gamma_studies, DeltaTStar, DeltaT, Moderators = 1, Mod)


# Afterwards: Make PhiPlot of overallPhi
DeltaTStar <- 1
out_CTmeta <- CTMA(N, 0, Phi, SigmaVAR, Gamma, DeltaTStar, DeltaT, Moderators = 0, Mod = NULL, FEorRE = 1, alpha=0.05)
q <- sqrt(length(out_CTmeta$Overall_standPhi_DeltaTStar))
overallPhi <- matrix(out_CTmeta$Overall_standPhi_DeltaTStar, byrow = T, ncol = q)
overallDrift <- logm(overallPhi)/DeltaTStar # Use expm package
PhiPlot(DeltaTStar, overallDrift, Min = 0, Max = 40, Step = 0.5)
}
